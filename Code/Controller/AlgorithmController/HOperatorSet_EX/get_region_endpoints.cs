//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        public static void get_region_endpoints(HObject ho_Region, HTuple hv_PolygonTolerance,
            HTuple hv_AngleTolerance, out HTuple hv_EndPointsRows, out HTuple hv_EndPointsColumns,
            out HTuple hv_ErrorString, out HTuple hv_ErrorCode)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_EndPointsIndex = new HTuple(), hv_i = new HTuple();
            HTuple hv_Angle = new HTuple(), hv_Exception = null;
            // Initialize local and output iconic variables 
            hv_EndPointsRows = new HTuple();
            hv_EndPointsColumns = new HTuple();
            hv_ErrorCode = -1;
            hv_ErrorString = "";
            try
            {
                //求区域多边形的定点
                //PolygonTolerance表示区域的点与近似多边形之间的距离公差，具体查看get_region_polygon函数
                HOperatorSet.GetRegionPolygon(ho_Region, hv_PolygonTolerance, out hv_Rows,
                    out hv_Columns);

                //第一个端点是区域多边形的y最小、x最大的那个端点
                hv_EndPointsRows = hv_Rows[0];
                hv_EndPointsColumns = hv_Columns[0];
                //端点索引
                hv_EndPointsIndex = 0;

                //消除位于一条边中间的端点，只取该边起始点和终止点作为有效端点
                for (hv_i = 1; (int)hv_i <= (int)((new HTuple(hv_Rows.TupleLength())) - 2); hv_i = (int)hv_i + 1)
                {
                    //如果多边形的端点索引是i，那么求直线L1（多边形端点i-1和多边形端点i构成的直线）和
                    //直线L2（多边形端点i和多边形端点i+1构成的直线）的夹角
                    HOperatorSet.AngleLl(hv_Rows.TupleSelect(hv_i - 1), hv_Columns.TupleSelect(
                        hv_i - 1), hv_Rows.TupleSelect(hv_i), hv_Columns.TupleSelect(hv_i), hv_Rows.TupleSelect(
                        hv_i), hv_Columns.TupleSelect(hv_i), hv_Rows.TupleSelect(hv_i + 1), hv_Columns.TupleSelect(
                        hv_i + 1), out hv_Angle);
                    //如果角度大于角度公差，那么该多边形端点作为有效端点，否则作为无效端点
                    if ((int)(new HTuple(((((hv_Angle.TupleDeg())).TupleAbs())).TupleGreater(
                        hv_AngleTolerance))) != 0)
                    {
                        hv_EndPointsIndex = hv_EndPointsIndex + 1;
                        hv_EndPointsRows = hv_EndPointsRows.TupleConcat(hv_Rows.TupleSelect(hv_i));
                        hv_EndPointsColumns = hv_EndPointsColumns.TupleConcat(hv_Columns.TupleSelect(
                            hv_i));

                    }
                    hv_ErrorCode = 1;
                    hv_ErrorString = "ok";
                }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_ErrorCode = -1;
                hv_ErrorString = "函数内部错误";
            }

            return;
        }

    }
}