//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        public static void get_rectangle2_points(HTuple hv_CenterY, HTuple hv_CenterX, HTuple hv_Phi,
            HTuple hv_Len1, HTuple hv_Len2, out HTuple hv_CornerY, out HTuple hv_CornerX,
            out HTuple hv_LineCenterY, out HTuple hv_LineCenterX)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RowT = null, hv_ColT = null, hv_Cos = null;
            HTuple hv_Sin = null;
            // Initialize local and output iconic variables 
            //矩形端点坐标变量、边中心坐标变量初始化
            hv_CornerX = new HTuple();
            hv_CornerY = new HTuple();
            hv_LineCenterX = new HTuple();
            hv_LineCenterY = new HTuple();

            //临时变量初始化
            hv_RowT = 0;
            hv_ColT = 0;

            //判断仿射矩形是否有效
            if ((int)((new HTuple(hv_Len1.TupleLessEqual(0))).TupleOr(new HTuple(hv_Len2.TupleLessEqual(
                0)))) != 0)
            {

                return;
            }

            //计算仿射矩形角度的正弦值、余弦值
            HOperatorSet.TupleCos(hv_Phi, out hv_Cos);
            HOperatorSet.TupleSin(hv_Phi, out hv_Sin);

            //矩形第一个端点坐标
            hv_ColT = (hv_CenterX - (hv_Len1 * hv_Cos)) - (hv_Len2 * hv_Sin);
            hv_RowT = hv_CenterY - (((-hv_Len1) * hv_Sin) + (hv_Len2 * hv_Cos));
            hv_CornerY = hv_CornerY.TupleConcat(hv_RowT);
            hv_CornerX = hv_CornerX.TupleConcat(hv_ColT);

            //矩形第二个端点坐标
            hv_ColT = (hv_CenterX + (hv_Len1 * hv_Cos)) - (hv_Len2 * hv_Sin);
            hv_RowT = hv_CenterY - ((hv_Len1 * hv_Sin) + (hv_Len2 * hv_Cos));
            hv_CornerY = hv_CornerY.TupleConcat(hv_RowT);
            hv_CornerX = hv_CornerX.TupleConcat(hv_ColT);

            //矩形第三个端点坐标
            hv_ColT = (hv_CenterX + (hv_Len1 * hv_Cos)) + (hv_Len2 * hv_Sin);
            hv_RowT = hv_CenterY - ((hv_Len1 * hv_Sin) - (hv_Len2 * hv_Cos));
            hv_CornerY = hv_CornerY.TupleConcat(hv_RowT);
            hv_CornerX = hv_CornerX.TupleConcat(hv_ColT);

            //矩形第四个端点坐标
            hv_ColT = (hv_CenterX - (hv_Len1 * hv_Cos)) + (hv_Len2 * hv_Sin);
            hv_RowT = hv_CenterY - (((-hv_Len1) * hv_Sin) - (hv_Len2 * hv_Cos));
            hv_CornerY = hv_CornerY.TupleConcat(hv_RowT);
            hv_CornerX = hv_CornerX.TupleConcat(hv_ColT);

            //矩形第一条边中心坐标
            if (hv_LineCenterY == null)
                hv_LineCenterY = new HTuple();
            hv_LineCenterY[0] = ((hv_CornerY.TupleSelect(0)) + (hv_CornerY.TupleSelect(1))) * 0.5;
            if (hv_LineCenterX == null)
                hv_LineCenterX = new HTuple();
            hv_LineCenterX[0] = ((hv_CornerX.TupleSelect(0)) + (hv_CornerX.TupleSelect(1))) * 0.5;

            //矩形第二条边中心坐标
            if (hv_LineCenterY == null)
                hv_LineCenterY = new HTuple();
            hv_LineCenterY[1] = ((hv_CornerY.TupleSelect(1)) + (hv_CornerY.TupleSelect(2))) * 0.5;
            if (hv_LineCenterX == null)
                hv_LineCenterX = new HTuple();
            hv_LineCenterX[1] = ((hv_CornerX.TupleSelect(1)) + (hv_CornerX.TupleSelect(2))) * 0.5;

            //矩形第三条边中心坐标
            if (hv_LineCenterY == null)
                hv_LineCenterY = new HTuple();
            hv_LineCenterY[2] = ((hv_CornerY.TupleSelect(3)) + (hv_CornerY.TupleSelect(2))) * 0.5;
            if (hv_LineCenterX == null)
                hv_LineCenterX = new HTuple();
            hv_LineCenterX[2] = ((hv_CornerX.TupleSelect(3)) + (hv_CornerX.TupleSelect(2))) * 0.5;

            //矩形第四边中心坐标
            if (hv_LineCenterY == null)
                hv_LineCenterY = new HTuple();
            hv_LineCenterY[3] = ((hv_CornerY.TupleSelect(3)) + (hv_CornerY.TupleSelect(0))) * 0.5;
            if (hv_LineCenterX == null)
                hv_LineCenterX = new HTuple();
            hv_LineCenterX[3] = ((hv_CornerX.TupleSelect(3)) + (hv_CornerX.TupleSelect(0))) * 0.5;

            //返回

            return;
        }

    }
}