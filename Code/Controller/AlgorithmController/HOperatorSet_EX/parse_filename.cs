//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        // Chapter: File
        // Short Description: Parse a filename into directory, base filename, and extension 
        public static void parse_filename(HTuple hv_FileName, out HTuple hv_BaseName, out HTuple hv_Extension,
            out HTuple hv_Directory)
        {



            // Local control variables 

            HTuple hv_DirectoryTmp = null, hv_Substring = null;
            // Initialize local and output iconic variables 
            //This procedure gets a filename (with full path) as input
            //and returns the directory path, the base filename and the extension
            //in three different strings.
            //
            //In the output path the path separators will be replaced
            //by '/' in all cases.
            //
            //The procedure shows the possibilities of regular expressions in HALCON.
            //
            //Input parameters:
            //FileName: The input filename
            //
            //Output parameters:
            //BaseName: The filename without directory description and file extension
            //Extension: The file extension
            //Directory: The directory path
            //
            //Example:
            //basename('C:/images/part_01.png',...) returns
            //BaseName = 'part_01'
            //Extension = 'png'
            //Directory = 'C:\\images\\' (on Windows systems)
            //
            //Explanation of the regular expressions:
            //
            //'([^\\\\/]*?)(?:\\.[^.]*)?$':
            //To start at the end, the '$' matches the end of the string,
            //so it is best to read the expression from right to left.
            //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
            //That means, that this part is matched, but not captured
            //in contrast to the first bracketed group ([^\\\\/], see below.)
            //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
            //So (?:\\.[^.]*)? matches the file extension, if any.
            //The '?' at the end assures, that even if no extension exists,
            //a correct match is returned.
            //The first part in brackets ([^\\\\/]*?) is a capture group,
            //which means, that if a match is found, only the part in
            //brackets is returned as a result.
            //Because both HDevelop strings and regular expressions need a '\\'
            //to describe a backslash, inside regular expressions within HDevelop
            //a backslash has to be written as '\\\\'.
            //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
            //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
            //where the '?' after the '*' switches the greediness off,
            //that means, that the shortest possible match is returned.
            //This option is necessary to cut off the extension
            //but only if (?:\\.[^.]*)? is able to match one.
            //To summarize, the regular expression matches that part of
            //the input string, that follows after the last '/' or '\\' and
            //cuts off the extension (if any) after the last '.'.
            //
            //'\\.([^.]*)$':
            //This matches everything after the last '.' of the input string.
            //Because ([^.]) is a capturing group,
            //only the part after the dot is returned.
            //
            //'.*[\\\\/]':
            //This matches the longest substring with a '/' or a '\\' at the end.
            //
            HOperatorSet.TupleRegexpMatch(hv_FileName, ".*[\\\\/]", out hv_DirectoryTmp);
            HOperatorSet.TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen()
                ) - 1, out hv_Substring);
            HOperatorSet.TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", out hv_BaseName);
            HOperatorSet.TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", out hv_Extension);
            //
            //
            //Finally all found backslashes ('\\') are converted
            //to a slash to get consistent paths
            HOperatorSet.TupleRegexpReplace(hv_DirectoryTmp, (new HTuple("\\\\")).TupleConcat(
                "replace_all"), "/", out hv_Directory);

            return;
        }
    }
}
