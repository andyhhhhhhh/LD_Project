//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;

namespace HOperatorSet_EX
{
    public partial class HOperatorSet_Ex
    {
        public static void region_to_rake_rectangle2(HObject ho_Image, HObject ho_Region, HTuple hv_Elements,
            HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold,
            HTuple hv_Tansition, HTuple hv_Select, HTuple hv_RefAngle, out HTuple hv_CornerYOut,
            out HTuple hv_CornerXOut, out HTuple hv_LineCenterYOut, out HTuple hv_LineCenterXOut,
            out HTuple hv_CenterYOut, out HTuple hv_CenterXOut, out HTuple hv_AngleOut,
            out HTuple hv_WidthOut, out HTuple hv_HeightOut, out HTuple hv_ExceptionOut)
        {




            // Local iconic variables 

            HObject ho_ConnectedRegions1 = null, ho_RegionFillUp1 = null;
            HObject ho_SelectedRegions1 = null, ho_RegionOpening = null;
            HObject ho_RegionClosing = null, ho_Regions = null, ho_Line = null;
            HObject ho_Cross = null, ho_SortedContours = null;

            // Local control variables 

            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Phi1 = new HTuple();
            HTuple hv_Length11 = new HTuple(), hv_Length21 = new HTuple();
            HTuple hv_CornerY = new HTuple(), hv_CornerX = new HTuple();
            HTuple hv_LineCenterY = new HTuple(), hv_LineCenterX = new HTuple();
            HTuple hv_LineRow1 = new HTuple(), hv_LineCol1 = new HTuple();
            HTuple hv_LineRow2 = new HTuple(), hv_LineCol2 = new HTuple();
            HTuple hv_i = new HTuple(), hv_ResultRow = new HTuple();
            HTuple hv_ResultColumn = new HTuple(), hv_Row11 = new HTuple();
            HTuple hv_Column11 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_Row3 = new HTuple();
            HTuple hv_Column3 = new HTuple(), hv_IsParallel = new HTuple();
            HTuple hv_Col = new HTuple(), hv_Angle = new HTuple();
            HTuple hv_AngleDiffMin = new HTuple(), hv_AngleT0 = new HTuple();
            HTuple hv_AngleT1 = new HTuple(), hv_AngleT2 = new HTuple();
            HTuple hv_AngleT3 = new HTuple(), hv_AngleT = new HTuple();
            HTuple hv_Radius = new HTuple(), hv_Distance = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_RegionFillUp1);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_RegionClosing);
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_SortedContours);
            hv_CornerYOut = new HTuple();
            hv_CornerXOut = new HTuple();
            hv_LineCenterYOut = new HTuple();
            hv_LineCenterXOut = new HTuple();
            hv_CenterYOut = new HTuple();
            hv_CenterXOut = new HTuple();
            hv_AngleOut = new HTuple();
            hv_WidthOut = new HTuple();
            hv_HeightOut = new HTuple();
            try
            {
                hv_ExceptionOut = 0;
                //预处理，获取区域外接rect2的定点和边中点
                ho_ConnectedRegions1.Dispose();
                HOperatorSet.Connection(ho_Region, out ho_ConnectedRegions1);
                ho_RegionFillUp1.Dispose();
                HOperatorSet.FillUp(ho_ConnectedRegions1, out ho_RegionFillUp1);
                ho_SelectedRegions1.Dispose();
                HOperatorSet.SelectShapeStd(ho_RegionFillUp1, out ho_SelectedRegions1, "max_area",
                    70);
                HOperatorSet.SmallestRectangle2(ho_SelectedRegions1, out hv_Row, out hv_Column,
                    out hv_Phi, out hv_Length1, out hv_Length2);
                ho_RegionOpening.Dispose();
                HOperatorSet.OpeningCircle(ho_SelectedRegions1, out ho_RegionOpening, hv_Length2 / 8);
                ho_RegionClosing.Dispose();
                HOperatorSet.ClosingCircle(ho_RegionOpening, out ho_RegionClosing, hv_Length2 / 6);
                HOperatorSet.SmallestRectangle2(ho_RegionClosing, out hv_Row1, out hv_Column1,
                    out hv_Phi1, out hv_Length11, out hv_Length21);
                get_rectangle2_points(hv_Row1, hv_Column1, hv_Phi1, hv_Length11, hv_Length21,
                    out hv_CornerY, out hv_CornerX, out hv_LineCenterY, out hv_LineCenterX);

                //rake拟合4条直线
                hv_LineRow1 = new HTuple();
                hv_LineCol1 = new HTuple();
                hv_LineRow2 = new HTuple();
                hv_LineCol2 = new HTuple();
                for (hv_i = 0; (int)hv_i <= 3; hv_i = (int)hv_i + 1)
                {
                    if ((int)(new HTuple(hv_i.TupleNotEqual(3))) != 0)
                    {
                        ho_Regions.Dispose();
                        rake(ho_Image, out ho_Regions, hv_Elements, hv_DetectHeight, hv_DetectWidth,
                            hv_Sigma, hv_Threshold, hv_Tansition, hv_Select, hv_CornerY.TupleSelect(
                            hv_i), hv_CornerX.TupleSelect(hv_i), hv_CornerY.TupleSelect(hv_i + 1),
                            hv_CornerX.TupleSelect(hv_i + 1), out hv_ResultRow, out hv_ResultColumn);
                    }
                    else
                    {
                        ho_Regions.Dispose();
                        rake(ho_Image, out ho_Regions, hv_Elements, hv_DetectHeight, hv_DetectWidth,
                            hv_Sigma, hv_Threshold, hv_Tansition, hv_Select, hv_CornerY.TupleSelect(
                            hv_i), hv_CornerX.TupleSelect(hv_i), hv_CornerY.TupleSelect(0), hv_CornerX.TupleSelect(
                            0), out hv_ResultRow, out hv_ResultColumn);
                    }
                    ho_Line.Dispose();
                    pts_to_best_line(out ho_Line, hv_ResultRow, hv_ResultColumn, 2, out hv_Row11,
                        out hv_Column11, out hv_Row2, out hv_Column2);

                    hv_LineRow1 = hv_LineRow1.TupleConcat(hv_Row11);
                    hv_LineCol1 = hv_LineCol1.TupleConcat(hv_Column11);
                    hv_LineRow2 = hv_LineRow2.TupleConcat(hv_Row2);
                    hv_LineCol2 = hv_LineCol2.TupleConcat(hv_Column2);
                }

                //求顶点
                hv_CornerYOut = new HTuple();
                hv_CornerXOut = new HTuple();
                for (hv_i = 0; (int)hv_i <= 3; hv_i = (int)hv_i + 1)
                {
                    if ((int)(new HTuple(hv_i.TupleNotEqual(3))) != 0)
                    {
                        HOperatorSet.IntersectionLl(hv_LineRow1.TupleSelect(hv_i), hv_LineCol1.TupleSelect(
                            hv_i), hv_LineRow2.TupleSelect(hv_i), hv_LineCol2.TupleSelect(hv_i),
                            hv_LineRow1.TupleSelect(hv_i + 1), hv_LineCol1.TupleSelect(hv_i + 1), hv_LineRow2.TupleSelect(
                            hv_i + 1), hv_LineCol2.TupleSelect(hv_i + 1), out hv_Row3, out hv_Column3,
                            out hv_IsParallel);
                    }
                    else
                    {
                        HOperatorSet.IntersectionLl(hv_LineRow1.TupleSelect(hv_i), hv_LineCol1.TupleSelect(
                            hv_i), hv_LineRow2.TupleSelect(hv_i), hv_LineCol2.TupleSelect(hv_i),
                            hv_LineRow1.TupleSelect(0), hv_LineCol1.TupleSelect(0), hv_LineRow2.TupleSelect(
                            0), hv_LineCol2.TupleSelect(0), out hv_Row3, out hv_Column3, out hv_IsParallel);
                    }

                    hv_CornerYOut = hv_CornerYOut.TupleConcat(hv_Row3);
                    hv_CornerXOut = hv_CornerXOut.TupleConcat(hv_Column3);

                }

                //求边中点
                hv_LineCenterYOut = new HTuple();
                hv_LineCenterXOut = new HTuple();
                for (hv_i = 0; (int)hv_i <= 3; hv_i = (int)hv_i + 1)
                {
                    if ((int)(new HTuple(hv_i.TupleNotEqual(3))) != 0)
                    {
                        hv_Row = 0.5 * ((hv_CornerYOut.TupleSelect(hv_i)) + (hv_CornerYOut.TupleSelect(
                            hv_i + 1)));
                        hv_Col = 0.5 * ((hv_CornerXOut.TupleSelect(hv_i)) + (hv_CornerXOut.TupleSelect(
                            hv_i + 1)));
                    }
                    else
                    {
                        hv_Row = 0.5 * ((hv_CornerYOut.TupleSelect(hv_i)) + (hv_CornerYOut.TupleSelect(
                            0)));
                        hv_Col = 0.5 * ((hv_CornerXOut.TupleSelect(hv_i)) + (hv_CornerXOut.TupleSelect(
                            0)));
                    }
                    hv_LineCenterYOut = hv_LineCenterYOut.TupleConcat(hv_Row);
                    hv_LineCenterXOut = hv_LineCenterXOut.TupleConcat(hv_Col);
                }

                //通过边中点连线的角度确定rect2角度
                hv_Angle = new HTuple();
                hv_AngleOut = new HTuple();
                hv_AngleDiffMin = 360;
                //求对边中点连线的角度，直线是矢量，a->b和b->a两个角度
                HOperatorSet.AngleLx(hv_LineCenterYOut.TupleSelect(0), hv_LineCenterXOut.TupleSelect(
                    0), hv_LineCenterYOut.TupleSelect(2), hv_LineCenterXOut.TupleSelect(2),
                    out hv_AngleT0);
                HOperatorSet.AngleLx(hv_LineCenterYOut.TupleSelect(2), hv_LineCenterXOut.TupleSelect(
                    2), hv_LineCenterYOut.TupleSelect(0), hv_LineCenterXOut.TupleSelect(0),
                    out hv_AngleT1);
                HOperatorSet.AngleLx(hv_LineCenterYOut.TupleSelect(1), hv_LineCenterXOut.TupleSelect(
                    1), hv_LineCenterYOut.TupleSelect(3), hv_LineCenterXOut.TupleSelect(3),
                    out hv_AngleT2);
                HOperatorSet.AngleLx(hv_LineCenterYOut.TupleSelect(3), hv_LineCenterXOut.TupleSelect(
                    3), hv_LineCenterYOut.TupleSelect(1), hv_LineCenterXOut.TupleSelect(1),
                    out hv_AngleT3);
                //求与参考角度夹角最小的角度作为输出
                hv_AngleT = new HTuple();
                hv_AngleT = hv_AngleT.TupleConcat(hv_AngleT0);
                hv_AngleT = hv_AngleT.TupleConcat(hv_AngleT1);
                hv_AngleT = hv_AngleT.TupleConcat(hv_AngleT2);
                hv_AngleT = hv_AngleT.TupleConcat(hv_AngleT3);
                for (hv_i = 0; (int)hv_i <= 3; hv_i = (int)hv_i + 1)
                {
                    hv_Angle = hv_Angle.TupleConcat(((hv_RefAngle - (((hv_AngleT.TupleSelect(hv_i))).TupleDeg()
                        ))).TupleAbs());
                    if ((int)(new HTuple(((((hv_RefAngle - (((hv_AngleT.TupleSelect(hv_i))).TupleDeg()
                        ))).TupleAbs())).TupleLessEqual(hv_AngleDiffMin))) != 0)
                    {
                        hv_AngleDiffMin = ((hv_RefAngle - (((hv_AngleT.TupleSelect(hv_i))).TupleDeg()
                            ))).TupleAbs();
                        hv_AngleOut = ((hv_AngleT.TupleSelect(hv_i))).TupleDeg();
                    }
                }

                //求rect2中心
                HOperatorSet.TupleMean(hv_CornerYOut, out hv_CenterYOut);
                HOperatorSet.TupleMean(hv_CornerXOut, out hv_CenterXOut);

                //求高度（垂直方向作为高度）和宽度（水平方向作为宽度）
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_CornerYOut, hv_CornerXOut,
                    2, 0);
                ho_SortedContours.Dispose();
                HOperatorSet.SortContoursXld(ho_Cross, out ho_SortedContours, "upper_left",
                    "true", "row");
                HOperatorSet.SmallestCircleXld(ho_SortedContours, out hv_Row, out hv_Column,
                    out hv_Radius);
                HOperatorSet.DistancePl(hv_Row.TupleSelectRange(0, 1), hv_Column.TupleSelectRange(
                    0, 1), hv_Row.TupleSelect(2), hv_Column.TupleSelect(2), hv_Row.TupleSelect(
                    3), hv_Column.TupleSelect(3), out hv_Distance);
                HOperatorSet.TupleMean(hv_Distance, out hv_HeightOut);

                ho_SortedContours.Dispose();
                HOperatorSet.SortContoursXld(ho_Cross, out ho_SortedContours, "upper_left",
                    "true", "column");
                HOperatorSet.SmallestCircleXld(ho_SortedContours, out hv_Row, out hv_Column,
                    out hv_Radius);
                HOperatorSet.DistancePl(hv_Row.TupleSelectRange(0, 1), hv_Column.TupleSelectRange(
                    0, 1), hv_Row.TupleSelect(2), hv_Column.TupleSelect(2), hv_Row.TupleSelect(
                    3), hv_Column.TupleSelect(3), out hv_Distance);
                HOperatorSet.TupleMean(hv_Distance, out hv_WidthOut);

            }
            // catch (ExceptionOut) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_ExceptionOut);
            }
            ho_ConnectedRegions1.Dispose();
            ho_RegionFillUp1.Dispose();
            ho_SelectedRegions1.Dispose();
            ho_RegionOpening.Dispose();
            ho_RegionClosing.Dispose();
            ho_Regions.Dispose();
            ho_Line.Dispose();
            ho_Cross.Dispose();
            ho_SortedContours.Dispose();

            return;
        }

    }
}