//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        public static void draw_spoke(HObject ho_Image, out HObject ho_Regions, HTuple hv_WindowHandle,
            HTuple hv_Elements, HTuple hv_DetectHeight, HTuple hv_DetectWidth, out HTuple hv_ROIRows,
            out HTuple hv_ROICols, out HTuple hv_Direct)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContOut1, ho_Contour, ho_ContCircle;
            HObject ho_Cross, ho_Rectangle1 = null, ho_Arrow1 = null;

            // Local control variables 

            HTuple hv_Rows = null, hv_Cols = null, hv_Weights = null;
            HTuple hv_Length1 = null, hv_RowC = null, hv_ColumnC = null;
            HTuple hv_Radius = null, hv_StartPhi = null, hv_EndPhi = null;
            HTuple hv_PointOrder = null, hv_RowXLD = null, hv_ColXLD = null;
            HTuple hv_Row1 = null, hv_Column1 = null, hv_Row2 = null;
            HTuple hv_Column2 = null, hv_DistanceStart = null, hv_DistanceEnd = null;
            HTuple hv_Length2 = null, hv_i = null, hv_j = new HTuple();
            HTuple hv_RowE = new HTuple(), hv_ColE = new HTuple();
            HTuple hv_ATan = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
            HTuple hv_ColL1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_ContOut1);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_ContCircle);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            hv_ROIRows = new HTuple();
            hv_ROICols = new HTuple();
            hv_Direct = new HTuple();
            //提示
            disp_message(hv_WindowHandle, "1、画4个以上点确定一个圆弧,点击右键确认",
                "window", 12, 12, "red", "false");
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //沿着圆弧或圆的边缘画点
            ho_ContOut1.Dispose();
            HOperatorSet.DrawNurbs(out ho_ContOut1, hv_WindowHandle, "true", "true",
                "true", "true", 3, out hv_Rows, out hv_Cols, out hv_Weights);
            //至少要4个点
            HOperatorSet.TupleLength(hv_Weights, out hv_Length1);
            if ((int)(new HTuple(hv_Length1.TupleLess(4))) != 0)
            {
                disp_message(hv_WindowHandle, "提示：点数太少，请重画", "window", 32,
                    12, "red", "false");
                hv_ROIRows = new HTuple();
                hv_ROICols = new HTuple();
                ho_ContOut1.Dispose();
                ho_Contour.Dispose();
                ho_ContCircle.Dispose();
                ho_Cross.Dispose();
                ho_Rectangle1.Dispose();
                ho_Arrow1.Dispose();

                return;
            }
            //获取点
            hv_ROIRows = hv_Rows.Clone();
            hv_ROICols = hv_Cols.Clone();
            //产生xld
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
            //用回归线法（不抛出异常点，所有点权重一样）拟合圆
            HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 3, 2, out hv_RowC,
                out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
            //根据拟合结果产生xld，并保持到显示对象
            ho_ContCircle.Dispose();
            HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius,
                hv_StartPhi, hv_EndPhi, hv_PointOrder, 3);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_Regions, ho_ContCircle, out ExpTmpOutVar_0);
                ho_Regions.Dispose();
                ho_Regions = ExpTmpOutVar_0;
            }

            //获取圆或圆弧xld上的点坐标
            HOperatorSet.GetContourXld(ho_ContCircle, out hv_RowXLD, out hv_ColXLD);
            //显示图像和圆弧
            HOperatorSet.DispObj(ho_Image, hv_WindowHandle);
            HOperatorSet.DispObj(ho_ContCircle, hv_WindowHandle);
            //产生并显示圆心
            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_RowC, hv_ColumnC, 60, 0.785398);
            HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
            //提示
            disp_message(hv_WindowHandle, "2、远离圆心，画箭头确定边缘检测方向，点击右键确认",
                "window", 12, 12, "red", "false");
            //画线，确定检测方向
            HOperatorSet.DrawLine(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_Row2,
                out hv_Column2);
            //求圆心到检测方向直线起点的距离
            HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row1, hv_Column1, out hv_DistanceStart);
            //求圆心到检测方向直线终点的距离
            HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row2, hv_Column2, out hv_DistanceEnd);

            //求圆或圆弧xld上的点的数量
            HOperatorSet.TupleLength(hv_ColXLD, out hv_Length2);
            //判断检测的边缘数量是否过少
            if ((int)(new HTuple(hv_Elements.TupleLess(3))) != 0)
            {
                hv_ROIRows = new HTuple();
                hv_ROICols = new HTuple();
                disp_message(hv_WindowHandle, "检测的边缘数量太少，请重新设置!", "window",
                    52, 12, "red", "false");
                ho_ContOut1.Dispose();
                ho_Contour.Dispose();
                ho_ContCircle.Dispose();
                ho_Cross.Dispose();
                ho_Rectangle1.Dispose();
                ho_Arrow1.Dispose();

                return;
            }
            //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
            //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
            HTuple end_val53 = hv_Elements - 1;
            HTuple step_val53 = 1;
            for (hv_i = 0; hv_i.Continue(end_val53, step_val53); hv_i = hv_i.TupleAdd(step_val53))
            {

                if ((int)(new HTuple(((hv_RowXLD.TupleSelect(0))).TupleEqual(hv_RowXLD.TupleSelect(
                    hv_Length2 - 1)))) != 0)
                {
                    //xld的起点和终点坐标相对，为圆
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / hv_Elements) * hv_i, out hv_j);

                }
                else
                {
                    //否则为圆弧
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / (hv_Elements - 1)) * hv_i, out hv_j);
                }
                //索引越界，强制赋值为最后一个索引
                if ((int)(new HTuple(hv_j.TupleGreaterEqual(hv_Length2))) != 0)
                {
                    hv_j = hv_Length2 - 1;
                    //continue
                }
                //获取卡尺工具中心
                hv_RowE = hv_RowXLD.TupleSelect(hv_j);
                hv_ColE = hv_ColXLD.TupleSelect(hv_j);

                //如果圆心到检测方向直线的起点的距离大于圆心到检测方向直线的终点的距离，搜索方向由圆外指向圆心
                //如果圆心到检测方向直线的起点的距离不大于圆心到检测方向直线的终点的距离，搜索方向由圆心指向圆外
                if ((int)(new HTuple(hv_DistanceStart.TupleGreater(hv_DistanceEnd))) != 0)
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                    //角度反向
                    hv_ATan = ((new HTuple(180)).TupleRad()) + hv_ATan;
                    //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                    hv_Direct = "inner";
                }
                else
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                    //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                    hv_Direct = "outer";
                }

                //产生卡尺xld，并保持到显示对象
                ho_Rectangle1.Dispose();
                HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan,
                    hv_DetectHeight / 2, hv_DetectWidth / 2);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle1, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }

                //用箭头xld指示边缘搜索方向，并保持到显示对象
                if ((int)(new HTuple(hv_i.TupleEqual(0))) != 0)
                {
                    hv_RowL2 = hv_RowE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_RowL1 = hv_RowE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_ColL2 = hv_ColE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    hv_ColL1 = hv_ColE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    ho_Arrow1.Dispose();
                    gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                        25, 25);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }
            }

            ho_ContOut1.Dispose();
            ho_Contour.Dispose();
            ho_ContCircle.Dispose();
            ho_Cross.Dispose();
            ho_Rectangle1.Dispose();
            ho_Arrow1.Dispose();

            return;
        }
    }
}
