//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        public static void pts_to_best_circle(out HObject ho_Circle, HTuple hv_Rows, HTuple hv_Cols,
            HTuple hv_ActiveNum, HTuple hv_ArcType, out HTuple hv_RowCenter, out HTuple hv_ColCenter,
            out HTuple hv_Radius, out HTuple hv_StartPhi, out HTuple hv_EndPhi, out HTuple hv_PointOrder,
            out HTuple hv_ArcAngle)
        {



            // Local iconic variables 

            HObject ho_Contour = null;

            // Local control variables 

            HTuple hv_Length = null, hv_Length1 = new HTuple();
            HTuple hv_CircleLength = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            hv_StartPhi = new HTuple();
            hv_EndPhi = new HTuple();
            hv_PointOrder = new HTuple();
            hv_ArcAngle = new HTuple();
            //初始化
            hv_RowCenter = 0;
            hv_ColCenter = 0;
            hv_Radius = 0;
            //产生一个空的直线对象，用于保存拟合后的圆
            ho_Circle.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Circle);
            //计算边缘数量
            HOperatorSet.TupleLength(hv_Cols, out hv_Length);
            //当边缘数量不小于有效点数时进行拟合
            if ((int)((new HTuple(hv_Length.TupleGreaterEqual(hv_ActiveNum))).TupleAnd(new HTuple(hv_ActiveNum.TupleGreater(
                2)))) != 0)
            {
                //halcon的拟合是基于xld的，需要把边缘连接成xld
                if ((int)(new HTuple(hv_ArcType.TupleEqual("circle"))) != 0)
                {
                    //如果是闭合的圆，轮廓需要首尾相连
                    ho_Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows.TupleConcat(hv_Rows.TupleSelect(
                        0)), hv_Cols.TupleConcat(hv_Cols.TupleSelect(0)));
                }
                else
                {
                    ho_Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows, hv_Cols);
                }
                //拟合圆。使用的算法是''geotukey''，其他算法请参考fit_circle_contour_xld的描述部分。
                HOperatorSet.FitCircleContourXld(ho_Contour, "geotukey", -1, 0, 0, 3, 2, out hv_RowCenter,
                    out hv_ColCenter, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
                //判断拟合结果是否有效：如果拟合成功，数组中元素的数量大于0
                HOperatorSet.TupleLength(hv_StartPhi, out hv_Length1);
                if ((int)(new HTuple(hv_Length1.TupleLess(1))) != 0)
                {
                    ho_Contour.Dispose();

                    return;
                }
                //根据拟合结果，产生直线xld
                if ((int)(new HTuple(hv_ArcType.TupleEqual("arc"))) != 0)
                {
                    //判断圆弧的方向：顺时针还是逆时针
                    //halcon求圆弧会出现方向混乱的问题
                    //tuple_mean (Rows, RowsMean)
                    //tuple_mean (Cols, ColsMean)
                    //gen_cross_contour_xld (Cross, RowsMean, ColsMean, 6, 0.785398)
                    //gen_circle_contour_xld (Circle1, RowCenter, ColCenter, Radius, StartPhi, EndPhi, 'positive', 1)
                    //求轮廓1中心
                    //area_center_points_xld (Circle1, Area, Row1, Column1)
                    //gen_circle_contour_xld (Circle2, RowCenter, ColCenter, Radius, StartPhi, EndPhi, 'negative', 1)
                    //求轮廓2中心
                    //area_center_points_xld (Circle2, Area, Row2, Column2)
                    //distance_pp (RowsMean, ColsMean, Row1, Column1, Distance1)
                    //distance_pp (RowsMean, ColsMean, Row2, Column2, Distance2)
                    //ArcAngle := EndPhi-StartPhi
                    //if (Distance1<Distance2)

                    //PointOrder := 'positive'
                    //copy_obj (Circle1, Circle, 1, 1)
                    //else

                    //PointOrder := 'negative'
                    //if (abs(ArcAngle)>3.1415926)
                    //ArcAngle := ArcAngle-2.0*3.1415926
                    //endif
                    //copy_obj (Circle2, Circle, 1, 1)
                    //endif
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);

                    HOperatorSet.LengthXld(ho_Circle, out hv_CircleLength);
                    hv_ArcAngle = hv_EndPhi - hv_StartPhi;
                    if ((int)(new HTuple(hv_CircleLength.TupleGreater(((new HTuple(180)).TupleRad()
                        ) * hv_Radius))) != 0)
                    {
                        if ((int)(new HTuple(((hv_ArcAngle.TupleAbs())).TupleLess((new HTuple(180)).TupleRad()
                            ))) != 0)
                        {
                            if ((int)(new HTuple(hv_ArcAngle.TupleGreater(0))) != 0)
                            {
                                hv_ArcAngle = ((new HTuple(360)).TupleRad()) - hv_ArcAngle;
                            }
                            else
                            {

                                hv_ArcAngle = ((new HTuple(360)).TupleRad()) + hv_ArcAngle;
                            }
                        }
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_CircleLength.TupleLess(((new HTuple(180)).TupleRad()
                            ) * hv_Radius))) != 0)
                        {
                            if ((int)(new HTuple(((hv_ArcAngle.TupleAbs())).TupleGreater((new HTuple(180)).TupleRad()
                                ))) != 0)
                            {
                                if ((int)(new HTuple(hv_ArcAngle.TupleGreater(0))) != 0)
                                {
                                    hv_ArcAngle = hv_ArcAngle - ((new HTuple(360)).TupleRad());

                                }
                                else
                                {
                                    hv_ArcAngle = ((new HTuple(360)).TupleRad()) + hv_ArcAngle;
                                }
                            }
                        }

                    }

                }
                else
                {
                    hv_StartPhi = 0;
                    hv_EndPhi = (new HTuple(360)).TupleRad();
                    hv_ArcAngle = (new HTuple(360)).TupleRad();
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);
                }
            }

            ho_Contour.Dispose();

            return;
        }

    }
}