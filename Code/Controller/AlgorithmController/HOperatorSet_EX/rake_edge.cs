//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        public static void rake_edge(HObject ho_Image, out HObject ho_Regions, HTuple hv_CenterRow,
            HTuple hv_CenterCol, HTuple hv_Phi, HTuple hv_Length1, HTuple hv_Length2,
            HTuple hv_Elements,
            HTuple hv_DetectHeight,
            HTuple hv_DetectWidth,
            HTuple hv_Sigma,
            HTuple hv_Threshold,
            HTuple hv_Transition,
            HTuple hv_Select, 
            out HTuple hv_ResultRow, out HTuple hv_ResultColumn)
        {
            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
            // Local iconic variables 
            HObject ho_Rectangle = null, ho_Arrow1 = null;
            // Local control variables 
            HTuple hv_Row1 = null, hv_Col1 = null;
            HTuple hv_Rowlen2 = null, hv_Collen2 = null, hv_Width = null;
            HTuple hv_Height = null, hv_RowEdge = new HTuple(), hv_Amplitude = new HTuple();
            HTuple hv_Distance = new HTuple(), hv_i = null, hv_RowC = new HTuple();
            HTuple hv_ColC = new HTuple(), hv_RowL1 = new HTuple();
            HTuple hv_ColL1 = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_ColL2 = new HTuple(), hv_MsrHandle_Measure = new HTuple();
            HTuple hv_ColEdge = new HTuple(), hv_tRow = new HTuple();
            HTuple hv_tCol = new HTuple(), hv_t = new HTuple(), hv_Number = new HTuple();
            HTuple hv_j = new HTuple();
            HTuple hv_DetectWidth_COPY_INP_TMP = hv_DetectWidth.Clone();
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            //*************************输入
            //Image:输入图像
            //CenterRow:输入矩形框的行中心
            //CenterCol:输入矩形框的列中心
            //Phi:输入矩形框的角度
            //Length1:输入矩形框的宽度
            //Length2:输入矩形框的高度
            //Step:扫描间隔
            //Sigma:高期平滑度
            //Threshold:最小边缘过渡
            //Transition:边缘提取方式,'negative'从白到黑,'positive'从黑到白,'all'都可以
            //Select:选取点方式,'first'第一个,'last'最后一个,'all'两者都有
         
            //************************输出
            //RowBegin:边的起始行
            //ColBegin:边的起始列
            //RowEnd:边的终点行
            //ColEnd:边的终点列

            //是否显示搜索区域
            //if (ShowSearchArea='TRUE')
            //在搜索框外显示角度指示箭头
            //gen_arrow_contour_xld (Arrow, CenterRow+sin(Phi)*(Length1+20), CenterCol-cos(Phi)*(Length1+20), CenterRow+sin(Phi)*(Length1), CenterCol-cos(Phi)*(Length1), 10, 10)
            //生成搜索框
            //gen_rectangle2 (Rectangle, CenterRow, CenterCol, Phi, Length1, Length2)
            //dev_set_color ('green')
            //dev_set_line_width (2)
            //dev_display (Arrow)
            //dev_display (Rectangle)
            //endif

            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);

            /// HOperatorSet.SetLineWidth(Win, 1);
            //初始化结果点的行列
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();
            hv_Row1 = new HTuple();
            hv_Col1 = new HTuple();

            if (hv_Rowlen2 == null)
                hv_Rowlen2 = new HTuple();
            hv_Rowlen2[0] = hv_CenterRow + ((((hv_Phi + ((new HTuple(90)).TupleRad()))).TupleSin()
                ) * hv_Length2);
            if (hv_Collen2 == null)
                hv_Collen2 = new HTuple();
            hv_Collen2[0] = hv_CenterCol - ((((hv_Phi + ((new HTuple(90)).TupleRad()))).TupleCos()
                ) * hv_Length2);
            if (hv_Rowlen2 == null)
                hv_Rowlen2 = new HTuple();
            hv_Rowlen2[1] = hv_CenterRow - ((((hv_Phi + ((new HTuple(90)).TupleRad()))).TupleSin()
                ) * hv_Length2);
            if (hv_Collen2 == null)
                hv_Collen2 = new HTuple();
            hv_Collen2[1] = hv_CenterCol + ((((hv_Phi + ((new HTuple(90)).TupleRad()))).TupleCos()
                ) * hv_Length2);
            //gen_arrow_contour_xld (Arrow1, Rowlen2[0], Collen2[0], Rowlen2[1], Collen2[1], 10, 10)
            //* concat_obj (Regions, Arrow1, Regions)

            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //循环扫描点
            //* for Index := 0 to Length2*2/Elements by 1
            //生成测量矩形,宽度为0,即为一条直线
            //* gen_measure_rectangle2 (CenterRow-cos(Phi)*(Length2-Elements*Index), CenterCol-sin(Phi)*(Length2-Elements*Index), Phi, Length1, 0, Width, Height, 'nearest_neighbor', MeasureHandle1)
            //是否显示搜索线
            //* Row1[0] := (CenterRow-cos(Phi)*(Length2-Elements*Index))+sin(Phi)*(Length1)
            //* Col1[0] := (CenterCol-sin(Phi)*(Length2-Elements*Index))-cos(Phi)*(Length1)
            //* Row1[1] := (CenterRow-cos(Phi)*(Length2-Elements*Index))-sin(Phi)*(Length1)
            //* Col1[1] := (CenterCol-sin(Phi)*(Length2-Elements*Index))+cos(Phi)*(Length1)
            //gen_contour_polygon_xld (Contour1, Row1, Col1)
            //把xld存储到显示对象
            //* concat_obj (Regions, Contour1, Regions)
            //测量点
            //* measure_pos (Image, MeasureHandle1, Sigma, Threshold, Transition, Select, RowEdge, ColumnEdge, Amplitude, Distance)
            //* close_measure (MeasureHandle1)
            //计算结果点的行列个数
            //* if (|RowEdge|>0)
            //* ResultRow := [ResultRow,RowEdge]
            //* ResultColumn := [ResultColumn,ColumnEdge]
            //* endif

            HTuple end_val73 = hv_Elements;
            HTuple step_val73 = 1;
            for (hv_i = 1; hv_i.Continue(end_val73, step_val73); hv_i = hv_i.TupleAdd(step_val73))
            {
                //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
                if ((int)(new HTuple(hv_Elements.TupleEqual(1))) != 0)
                {
                    hv_RowC = ((hv_Rowlen2.TupleSelect(0)) + (hv_Rowlen2.TupleSelect(1))) * 0.5;
                    hv_ColC = ((hv_Collen2.TupleSelect(0)) + (hv_Collen2.TupleSelect(1))) * 0.5;
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    HOperatorSet.DistancePp(hv_Rowlen2.TupleSelect(0), hv_Collen2.TupleSelect(
                        0), hv_Rowlen2.TupleSelect(1), hv_Collen2.TupleSelect(1), out hv_Distance);
                    hv_DetectWidth_COPY_INP_TMP = hv_Length2.Clone();
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                        hv_Phi, hv_DetectHeight, hv_DetectWidth_COPY_INP_TMP / 2);
                }
                else
                {
                    //如果有多个测量矩形，产生该测量矩形xld
                    hv_RowC = (hv_Rowlen2.TupleSelect(0)) + ((((hv_Rowlen2.TupleSelect(1)) - (hv_Rowlen2.TupleSelect(
                        0))) * (hv_i - 1)) / (hv_Elements - 1));
                    hv_ColC = (hv_Collen2.TupleSelect(0)) + ((((hv_Collen2.TupleSelect(1)) - (hv_Collen2.TupleSelect(
                        0))) * (hv_i - 1)) / (hv_Elements - 1));
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                        hv_Phi, hv_DetectHeight, hv_DetectWidth_COPY_INP_TMP / 2);
                }
                //把测量矩形xld存储到显示对象
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }

                if ((int)(new HTuple(hv_i.TupleEqual(1))) != 0)
                {
                    //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                    hv_RowL1 = hv_RowC + (hv_DetectHeight * (hv_Phi.TupleSin()));
                    hv_ColL1 = hv_ColC - (hv_DetectHeight * (hv_Phi.TupleCos()));
                    hv_RowL2 = hv_RowC - (hv_DetectHeight * (hv_Phi.TupleSin()));
                    hv_ColL2 = hv_ColC + (hv_DetectHeight * (hv_Phi.TupleCos()));
                    ho_Arrow1.Dispose();
                    gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                        hv_DetectWidth_COPY_INP_TMP, hv_DetectWidth_COPY_INP_TMP);
                    //把xld存储到显示对象
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }

                //产生测量对象句柄
                HOperatorSet.GenMeasureRectangle2(hv_RowC, hv_ColC, hv_Phi, hv_DetectHeight, hv_DetectWidth_COPY_INP_TMP / 2,
                    hv_Width, hv_Height, "nearest_neighbor", out hv_MsrHandle_Measure);
                //设置极性
                if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
                {
                    hv_Transition_COPY_INP_TMP = "negative";
                }
                else
                {
                    if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                    {

                        hv_Transition_COPY_INP_TMP = "positive";
                    }
                    else
                    {
                        hv_Transition_COPY_INP_TMP = "all";
                    }
                }
                //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
                if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
                {
                    hv_Select_COPY_INP_TMP = "first";
                }
                else
                {
                    if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                    {

                        hv_Select_COPY_INP_TMP = "last";
                    }
                    else
                    {
                        hv_Select_COPY_INP_TMP = "all";
                    }
                }
                //检测边缘
                HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                    hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                    out hv_Amplitude, out hv_Distance);
                //清除测量对象句柄
                HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);

                //临时变量初始化
                //tRow，tCol保存找到指定边缘的坐标
                hv_tRow = 0;
                hv_tCol = 0;
                //t保存边缘的幅度绝对值
                hv_t = 0;
                //找到的边缘必须至少为1个
                HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
                if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
                {
                    continue;
                }
                //有多个边缘时，选择幅度绝对值最大的边缘
                HTuple end_val150 = hv_Number - 1;
                HTuple step_val150 = 1;
                for (hv_j = 0; hv_j.Continue(end_val150, step_val150); hv_j = hv_j.TupleAdd(step_val150))
                {
                    if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                        hv_t))) != 0)
                    {

                        hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                        hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                        hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                    }
                }
                //把找到的边缘保存在输出数组
                if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
                {
                    hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                    hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
                }
            }

            //tuple_length (ResultRow, RL)
            //tuple_length (ResultColumn, CL)
            //结果点的行个数或列个数>=2拟合,防止报错
            //if (RL>1 or CL>1)
            //生成Contour
            //gen_contour_polygon_xld (Contour, ResultRow, ResultColumn)
            //拟合直线,参数可以更改或改成接口
            //*     fit_line_contour_xld (Contour, 'tukey', -1, 0, 0, 1, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)
            //else
            //置为-1,防止输出时画直线报错
            //RowBegin := -1
            //ColBegin := -1
            //RowEnd := -1
            //ColEnd := -1
            //endif
            ho_Rectangle.Dispose();
            ho_Arrow1.Dispose();

            return;
        }

    }
}