//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//


using System;
using HalconDotNet;
namespace HOperatorSet_EX
{

    public partial class HOperatorSet_Ex
    {
        // Chapter: Graphics / Output
        // Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
        public static void plot_tuple(HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues,
            HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames,
            HTuple hv_GenParamValues)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContourXGrid = null, ho_ContourYGrid = null;
            HObject ho_XArrow = null, ho_YArrow = null, ho_ContourXTick = null;
            HObject ho_ContourYTick = null, ho_Contour = null, ho_Cross = null;
            HObject ho_Filled = null;

            // Local control variables 

            HTuple hv_PreviousWindowHandle = new HTuple();
            HTuple hv_ClipRegion = null, hv_Row = null, hv_Column = null;
            HTuple hv_Width = null, hv_Height = null, hv_PartRow1 = null;
            HTuple hv_PartColumn1 = null, hv_PartRow2 = null, hv_PartColumn2 = null;
            HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
            HTuple hv_DrawMode = null, hv_OriginStyle = null, hv_XAxisEndValue = new HTuple();
            HTuple hv_YAxisEndValue = new HTuple(), hv_XAxisStartValue = new HTuple();
            HTuple hv_YAxisStartValue = new HTuple(), hv_XValuesAreStrings = new HTuple();
            HTuple hv_XTickValues = new HTuple(), hv_XTicks = null;
            HTuple hv_OriginX = null, hv_OriginY = null, hv_LeftBorder = null;
            HTuple hv_RightBorder = null, hv_UpperBorder = null, hv_LowerBorder = null;
            HTuple hv_AxesColor = null, hv_Style = null, hv_Clip = null;
            HTuple hv_YTicks = null, hv_XGrid = null, hv_YGrid = null;
            HTuple hv_GridColor = null, hv_NumGenParamNames = null;
            HTuple hv_NumGenParamValues = null, hv_SetOriginXToDefault = null;
            HTuple hv_SetOriginYToDefault = null, hv_GenParamIndex = null;
            HTuple hv_XGridTicks = new HTuple(), hv_XAxisWidthPx = null;
            HTuple hv_XAxisWidth = null, hv_XScaleFactor = null, hv_YAxisHeightPx = null;
            HTuple hv_YAxisHeight = null, hv_YScaleFactor = null, hv_YAxisOffsetPx = null;
            HTuple hv_XAxisOffsetPx = null, hv_DotStyle = new HTuple();
            HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
            HTuple hv_XPosition = new HTuple(), hv_IndexGrid = new HTuple();
            HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
            HTuple hv_YPosition = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
            HTuple hv_TextHeightXLabel = new HTuple(), hv_XTickStart = new HTuple();
            HTuple hv_TypeTicks = new HTuple(), hv_IndexTicks = new HTuple();
            HTuple hv_YTickValues = new HTuple(), hv_YTickStart = new HTuple();
            HTuple hv_Ascent1 = new HTuple(), hv_Descent1 = new HTuple();
            HTuple hv_TextWidthYTicks = new HTuple(), hv_TextHeightYTicks = new HTuple();
            HTuple hv_Num = new HTuple(), hv_I = new HTuple(), hv_YSelected = new HTuple();
            HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
            HTuple hv_XValues_COPY_INP_TMP = hv_XValues.Clone();
            HTuple hv_YValues_COPY_INP_TMP = hv_YValues.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
            HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
            HOperatorSet.GenEmptyObj(out ho_XArrow);
            HOperatorSet.GenEmptyObj(out ho_YArrow);
            HOperatorSet.GenEmptyObj(out ho_ContourXTick);
            HOperatorSet.GenEmptyObj(out ho_ContourYTick);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Filled);
            //This procedure plots tuples representing functions
            //or curves in a coordinate system.
            //
            //Input parameters:
            //
            //XValues: X values of the function to be plotted
            //         If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.
            //         If XValues is a tuple of strings, the values are taken as categories.
            //
            //YValues: Y values of the function(s) to be plotted
            //         If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.
            //         The number of y values must be equal to the number of x values
            //         or an integral multiple. In the latter case,
            //         multiple functions are plotted, that share the same x values.
            //
            //XLabel: X axis label
            //
            //XLabel: Y axis label
            //
            //Color: Color of the plotted function
            //       If [] is given, the currently set display color is used.
            //       If 'none is given, the function is not plotted, but only
            //       the coordinate axes as specified.
            //       If more than one color is given, multiple functions
            //       can be displayed in different colors.
            //
            //GenParamNames: Generic parameters to control the presentation
            //               Possible Values:
            //   'axes_color': coordinate system color
            //                 Default: 'white'
            //                 If 'none' is given, no coordinate system is shown.
            //   'style': Graph style
            //            Possible values: 'line' (default), 'cross', 'filled'
            //   'clip': Clip graph to coordinate system area
            //           Possibile values: 'yes', 'no' (default)
            //   'ticks': Control display of ticks on the axes
            //            If 'min_max_origin' is given (default), ticks are shown
            //            at the minimum and maximum values of the axes and at the
            //            intercept point of x- and y-axis.
            //            If 'none' is given, no ticks are shown.
            //            If any number != 0 is given, it is interpreted as distance
            //            between the ticks.
            //   'ticks_x': Control display of ticks on x-axis only
            //   'ticks_y': Control display of ticks on y-axis only
            //   'grid': Control display of grid lines within the coordinate system
            //           If 'min_max_origin' is given (default), grid lines are shown
            //           at the minimum and maximum values of the axes.
            //           If 'none' is given, no grid lines are shown.
            //           If any number != 0 is given, it is interpreted as distance
            //           between the grid lines.
            //   'grid_x': Control display of grid lines for the x-axis only
            //   'grid_y': Control display of grid lines for the y-axis only
            //   'grid_color': Color of the grid (default: 'dim gray')
            //   'margin': The distance in pixels of the coordinate system area
            //             to all four window borders.
            //   'margin_left': The distance in pixels of the coordinate system area
            //                  to the left window border.
            //   'margin_right': The distance in pixels of the coordinate system area
            //                   to the right window border.
            //   'margin_top': The distance in pixels of the coordinate system area
            //                 to the upper window border.
            //   'margin_bottom': The distance in pixels of the coordinate system area
            //                    to the lower window border.
            //   'start_x': Lowest x value of the x axis
            //              Default: min(XValues)
            //   'end_x': Highest x value of the x axis
            //            Default: max(XValues)
            //   'start_y': Lowest y value of the x axis
            //              Default: min(YValues)
            //   'end_y': Highest y value of the x axis
            //            Default: max(YValues)
            //   'origin_x': X coordinate of the intercept point of x- and y-axis.
            //               Default: same as start_x
            //   'origin_y': Y coordinate of the intercept point of x- and y-axis.
            //               Default: same as start_y
            //
            //GenParamValues: Values of the generic parameters of GenericParamNames
            //
            //
            //Store current display settings
            //dev_get_window(...);
            //dev_set_window(...);
            HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column,
                out hv_Width, out hv_Height);
            HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1,
                out hv_PartRow2, out hv_PartColumn2);
            HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
            HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
            //
            //Set display parameters
            HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
            HOperatorSet.SetSystem("clip_region", "false");
            HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_Height - 1, hv_Width - 1);
            //
            //Check input coordinates
            //
            if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
                new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
            {
                //Neither XValues nor YValues are given:
                //Set axes to interval [0,1]
                hv_XAxisEndValue = 1;
                hv_YAxisEndValue = 1;
                hv_XAxisStartValue = 0;
                hv_YAxisStartValue = 0;
                hv_XValuesAreStrings = 0;
            }
            else
            {
                if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                {
                    //XValues are omitted:
                    //Set equidistant XValues
                    hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(0, (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                        )) - 1, 1);
                    hv_XValuesAreStrings = 0;
                }
                else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                {
                    //YValues are omitted:
                    //Set equidistant YValues
                    hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(0, (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                        )) - 1, 1);
                }
                if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                    )) % (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
                    0))) != 0)
                {
                    //Number of YValues does not match number of XValues
                    throw new HalconException("Number of YValues is no multiple of the number of XValues!");
                    ho_ContourXGrid.Dispose();
                    ho_ContourYGrid.Dispose();
                    ho_XArrow.Dispose();
                    ho_YArrow.Dispose();
                    ho_ContourXTick.Dispose();
                    ho_ContourYTick.Dispose();
                    ho_Contour.Dispose();
                    ho_Cross.Dispose();
                    ho_Filled.Dispose();

                    return;
                }
                hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem();
                hv_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum())).TupleEqual(
                    new HTuple(hv_XValuesAreStrings.TupleLength())));
                if ((int)(hv_XValuesAreStrings) != 0)
                {
                    //XValues are given as strings:
                    //Show XValues as ticks
                    hv_XTickValues = hv_XValues_COPY_INP_TMP.Clone();
                    hv_XTicks = 1;
                    //Set x-axis dimensions
                    hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(1, new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                        ), 1);
                }
                //Set default x-axis dimensions
                if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin();
                    hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax();
                }
                else
                {
                    hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(0)) + 0.5;
                    hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(0)) - 0.5;
                }
            }
            //Set default y-axis dimensions
            if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                1))) != 0)
            {
                hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin();
                hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax();
            }
            else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                )).TupleEqual(1))) != 0)
            {
                hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(0)) - 0.5;
                hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(0)) + 0.5;
            }
            else
            {
                hv_YAxisStartValue = 0;
                hv_YAxisEndValue = 1;
            }
            //Set default interception point of x- and y- axis
            hv_OriginX = hv_XAxisStartValue.Clone();
            hv_OriginY = hv_YAxisStartValue.Clone();
            //
            //Set more defaults
            hv_LeftBorder = hv_Width * 0.1;
            hv_RightBorder = hv_Width * 0.1;
            hv_UpperBorder = hv_Height * 0.1;
            hv_LowerBorder = hv_Height * 0.1;
            hv_AxesColor = "white";
            hv_Style = "line";
            hv_Clip = "no";
            hv_XTicks = "min_max_origin";
            hv_YTicks = "min_max_origin";
            hv_XGrid = "none";
            hv_YGrid = "none";
            hv_GridColor = "dim gray";
            //
            //Parse generic parameters
            //
            hv_NumGenParamNames = new HTuple(hv_GenParamNames.TupleLength());
            hv_NumGenParamValues = new HTuple(hv_GenParamValues.TupleLength());
            if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
            {
                throw new HalconException("Number of generic parameter names does not match generic parameter values!");
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Filled.Dispose();

                return;
            }
            //
            hv_SetOriginXToDefault = 1;
            hv_SetOriginYToDefault = 1;
            for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
            {
                //
                //Set 'axes_color'
                if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "axes_color"))) != 0)
                {
                    hv_AxesColor = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'style'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "style"))) != 0)
                {
                    hv_Style = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'clip'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "clip"))) != 0)
                {
                    hv_Clip = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
                        "no")))) != 0)
                    {
                        throw new HalconException(("Unsupported clipping option: '" + hv_Clip) + "'");
                    }
                    //
                    //Set 'ticks'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "ticks"))) != 0)
                {
                    hv_XTicks = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_YTicks = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'ticks_x'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "ticks_x"))) != 0)
                {
                    hv_XTicks = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'ticks_y'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "ticks_y"))) != 0)
                {
                    hv_YTicks = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'grid'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "grid"))) != 0)
                {
                    hv_XGrid = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_YGrid = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_XGridTicks = hv_XTicks.Clone();
                    //
                    //Set 'grid_x'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "grid_x"))) != 0)
                {
                    hv_XGrid = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'grid_y'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "grid_y"))) != 0)
                {
                    hv_YGrid = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'grid_color'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "grid_color"))) != 0)
                {
                    hv_GridColor = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'start_x'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "start_x"))) != 0)
                {
                    hv_XAxisStartValue = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'end_x'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "end_x"))) != 0)
                {
                    hv_XAxisEndValue = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'start_y'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "start_y"))) != 0)
                {
                    hv_YAxisStartValue = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'end_y'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "end_y"))) != 0)
                {
                    hv_YAxisEndValue = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'origin_x'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "origin_x"))) != 0)
                {
                    hv_OriginX = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_SetOriginXToDefault = 0;
                    //
                    //Set 'origin_y'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "origin_y"))) != 0)
                {
                    hv_OriginY = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_SetOriginYToDefault = 0;
                    //
                    //Set 'margin'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "margin"))) != 0)
                {
                    hv_LeftBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_RightBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_UpperBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    hv_LowerBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'margin_left'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "margin_left"))) != 0)
                {
                    hv_LeftBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'margin_right'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "margin_right"))) != 0)
                {
                    hv_RightBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'margin_top'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "margin_top"))) != 0)
                {
                    hv_UpperBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                    //
                    //Set 'margin_bottom'
                }
                else if ((int)(new HTuple(((hv_GenParamNames.TupleSelect(hv_GenParamIndex))).TupleEqual(
                    "margin_bottom"))) != 0)
                {
                    hv_LowerBorder = hv_GenParamValues.TupleSelect(hv_GenParamIndex);
                }
                else
                {
                    throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamNames.TupleSelect(
                        hv_GenParamIndex))) + "'");
                }
            }
            //
            //
            //Check consistency of start and end values
            //of the axes.
            if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
            {
                throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
            }
            if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
            {
                throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
            }
            //
            //Set default origin to lower left corner
            if ((int)(hv_SetOriginXToDefault) != 0)
            {
                hv_OriginX = hv_XAxisStartValue.Clone();
            }
            if ((int)(hv_SetOriginYToDefault) != 0)
            {
                hv_OriginY = hv_YAxisStartValue.Clone();
            }
            //
            //
            //Calculate basic pixel coordinates and scale factors
            //
            hv_XAxisWidthPx = (hv_Width - hv_LeftBorder) - hv_RightBorder;
            hv_XAxisWidth = hv_XAxisEndValue - hv_XAxisStartValue;
            if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
            {
                hv_XAxisStartValue = hv_XAxisStartValue - 0.5;
                hv_XAxisEndValue = hv_XAxisEndValue + 0.5;
                hv_XAxisWidth = 1;
            }
            hv_XScaleFactor = hv_XAxisWidthPx / (hv_XAxisWidth.TupleReal());
            hv_YAxisHeightPx = (hv_Height - hv_LowerBorder) - hv_UpperBorder;
            hv_YAxisHeight = hv_YAxisEndValue - hv_YAxisStartValue;
            if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
            {
                hv_YAxisStartValue = hv_YAxisStartValue - 0.5;
                hv_YAxisEndValue = hv_YAxisEndValue + 0.5;
                hv_YAxisHeight = 1;
            }
            hv_YScaleFactor = hv_YAxisHeightPx / (hv_YAxisHeight.TupleReal());
            hv_YAxisOffsetPx = (hv_OriginX - hv_XAxisStartValue) * hv_XScaleFactor;
            hv_XAxisOffsetPx = (hv_OriginY - hv_YAxisStartValue) * hv_YScaleFactor;
            //
            //Display grid lines
            //
            if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
            {
                hv_DotStyle = new HTuple();
                hv_DotStyle[0] = 5;
                hv_DotStyle[1] = 7;
                HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
                HOperatorSet.SetColor(hv_WindowHandle, hv_GridColor);
                //
                //Display x grid lines
                if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
                {
                    if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
                    {
                        //Calculate 'min_max_origin' grid line coordinates
                        if ((int)(new HTuple(hv_OriginX.TupleEqual(hv_XAxisStartValue))) != 0)
                        {
                            hv_XGridValues = new HTuple();
                            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue);
                            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisEndValue);
                        }
                        else
                        {
                            hv_XGridValues = new HTuple();
                            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue);
                            hv_XGridValues = hv_XGridValues.TupleConcat(hv_OriginX);
                            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisEndValue);
                        }
                    }
                    else
                    {
                        //Calculate equidistant grid line coordinates
                        hv_XGridStart = (((hv_XAxisStartValue / hv_XGrid)).TupleCeil()) * hv_XGrid;
                        hv_XGridValues = HTuple.TupleGenSequence(hv_XGridStart, hv_XAxisEndValue,
                            hv_XGrid);
                    }
                    hv_XPosition = (hv_XGridValues - hv_XAxisStartValue) * hv_XScaleFactor;
                    //Generate and display grid lines
                    for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_XGridValues.TupleLength()
                        )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                    {
                        ho_ContourXGrid.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height - hv_LowerBorder)).TupleConcat(
                            hv_UpperBorder), ((hv_LeftBorder + (hv_XPosition.TupleSelect(hv_IndexGrid)))).TupleConcat(
                            hv_LeftBorder + (hv_XPosition.TupleSelect(hv_IndexGrid))));
                        HOperatorSet.DispObj(ho_ContourXGrid, hv_WindowHandle);
                    }
                }
                //
                //Display y grid lines
                if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
                {
                    if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
                    {
                        //Calculate 'min_max_origin' grid line coordinates
                        if ((int)(new HTuple(hv_OriginY.TupleEqual(hv_YAxisStartValue))) != 0)
                        {
                            hv_YGridValues = new HTuple();
                            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue);
                            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisEndValue);
                        }
                        else
                        {
                            hv_YGridValues = new HTuple();
                            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue);
                            hv_YGridValues = hv_YGridValues.TupleConcat(hv_OriginY);
                            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisEndValue);
                        }
                    }
                    else
                    {
                        //Calculate equidistant grid line coordinates
                        hv_YGridStart = (((hv_YAxisStartValue / hv_YGrid)).TupleCeil()) * hv_YGrid;
                        hv_YGridValues = HTuple.TupleGenSequence(hv_YGridStart, hv_YAxisEndValue,
                            hv_YGrid);
                    }
                    hv_YPosition = (hv_YGridValues - hv_YAxisStartValue) * hv_YScaleFactor;
                    //Generate and display grid lines
                    for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_YGridValues.TupleLength()
                        )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                    {
                        ho_ContourYGrid.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height - hv_LowerBorder) - (hv_YPosition.TupleSelect(
                            hv_IndexGrid)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YPosition.TupleSelect(
                            hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width - hv_RightBorder));
                        HOperatorSet.DispObj(ho_ContourYGrid, hv_WindowHandle);
                    }
                }
            }
            HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
            //
            //
            //Display the coordinate sytem axes
            if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
            {
                //Display axes
                HOperatorSet.SetColor(hv_WindowHandle, hv_AxesColor);
                ho_XArrow.Dispose();
                gen_arrow_contour_xld(out ho_XArrow, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx,
                    hv_LeftBorder, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx, hv_Width - hv_RightBorder,
                    0, 0);
                HOperatorSet.DispObj(ho_XArrow, hv_WindowHandle);
                ho_YArrow.Dispose();
                gen_arrow_contour_xld(out ho_YArrow, hv_Height - hv_LowerBorder, hv_LeftBorder + hv_YAxisOffsetPx,
                    hv_UpperBorder, hv_LeftBorder + hv_YAxisOffsetPx, 0, 0);
                HOperatorSet.DispObj(ho_YArrow, hv_WindowHandle);
                //Display labels
                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent,
                    out hv_Descent, out hv_TextWidthXLabel, out hv_TextHeightXLabel);
                disp_message(hv_WindowHandle, hv_XLabel, "window", ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - hv_XAxisOffsetPx,
                    ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3, hv_AxesColor, "false");
                disp_message(hv_WindowHandle, " " + hv_YLabel, "window", hv_UpperBorder,
                    (hv_LeftBorder + 3) + hv_YAxisOffsetPx, hv_AxesColor, "false");
            }
            //
            //Display ticks
            //
            if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
            {
                HOperatorSet.SetColor(hv_WindowHandle, hv_AxesColor);
                if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Display x ticks
                    if ((int)(hv_XValuesAreStrings) != 0)
                    {
                        //Display string XValues as categories
                        hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())) / (new HTuple(hv_XTickValues.TupleLength()
                            ));
                        hv_XPosition = (hv_XValues_COPY_INP_TMP - hv_XAxisStartValue) * hv_XScaleFactor;
                    }
                    else
                    {
                        //Display tick values
                        if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' tick coordinates
                            if ((int)(new HTuple(hv_OriginX.TupleEqual(hv_XAxisStartValue))) != 0)
                            {
                                hv_XTickValues = new HTuple();
                                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue);
                                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisEndValue);
                            }
                            else
                            {
                                hv_XTickValues = new HTuple();
                                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue);
                                hv_XTickValues = hv_XTickValues.TupleConcat(hv_OriginX);
                                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisEndValue);
                            }
                        }
                        else
                        {
                            //Calculate equidistant tick coordinates
                            hv_XTickStart = (((hv_XAxisStartValue / hv_XTicks)).TupleCeil()) * hv_XTicks;
                            hv_XTickValues = HTuple.TupleGenSequence(hv_XTickStart, hv_XAxisEndValue,
                                hv_XTicks);
                        }
                        hv_XPosition = (hv_XTickValues - hv_XAxisStartValue) * hv_XScaleFactor;
                        hv_TypeTicks = hv_XTicks.TupleType();
                        if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                        {
                            //String ('min_max_origin')
                            //Format depends on actual values
                            hv_TypeTicks = hv_XTickValues.TupleType();
                        }
                        if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                        {
                            //Round to integer
                            hv_XTickValues = hv_XTickValues.TupleInt();
                        }
                        else
                        {
                            //Use floating point numbers
                            hv_XTickValues = hv_XTickValues.TupleString(".2f");
                        }
                    }
                    //Generate and display ticks
                    for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_XTickValues.TupleLength()
                        )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                    {
                        ho_ContourXTick.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx)).TupleConcat(
                            ((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) - 5), ((hv_LeftBorder + (hv_XPosition.TupleSelect(
                            hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XPosition.TupleSelect(
                            hv_IndexTicks))));
                        HOperatorSet.DispObj(ho_ContourXTick, hv_WindowHandle);
                        disp_message(hv_WindowHandle, hv_XTickValues.TupleSelect(hv_IndexTicks),
                            "window", ((hv_Height - hv_LowerBorder) + 2) - hv_XAxisOffsetPx, hv_LeftBorder + (hv_XPosition.TupleSelect(
                            hv_IndexTicks)), hv_AxesColor, "false");
                    }
                }
                //
                if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Display y ticks
                    if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
                    {
                        //Calculate 'min_max_origin' tick coordinates
                        if ((int)(new HTuple(hv_OriginY.TupleEqual(hv_YAxisStartValue))) != 0)
                        {
                            hv_YTickValues = new HTuple();
                            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue);
                            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisEndValue);
                        }
                        else
                        {
                            hv_YTickValues = new HTuple();
                            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue);
                            hv_YTickValues = hv_YTickValues.TupleConcat(hv_OriginY);
                            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisEndValue);
                        }
                    }
                    else
                    {
                        //Calculate equidistant tick coordinates
                        hv_YTickStart = (((hv_YAxisStartValue / hv_YTicks)).TupleCeil()) * hv_YTicks;
                        hv_YTickValues = HTuple.TupleGenSequence(hv_YTickStart, hv_YAxisEndValue,
                            hv_YTicks);
                    }
                    hv_YPosition = (hv_YTickValues - hv_YAxisStartValue) * hv_YScaleFactor;
                    hv_TypeTicks = hv_YTicks.TupleType();
                    if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                    {
                        //String ('min_max_origin')
                        //Format depends on actual values
                        hv_TypeTicks = hv_YTickValues.TupleType();
                    }
                    if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                    {
                        //Round to integer
                        hv_YTickValues = hv_YTickValues.TupleInt();
                    }
                    else
                    {
                        //Use floating point numbers
                        hv_YTickValues = hv_YTickValues.TupleString(".2f");
                    }
                    //Generate and display ticks
                    for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_YTickValues.TupleLength()
                        )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                    {
                        ho_ContourYTick.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YPosition.TupleSelect(
                            hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YPosition.TupleSelect(
                            hv_IndexTicks))), ((hv_LeftBorder + hv_YAxisOffsetPx)).TupleConcat((hv_LeftBorder + hv_YAxisOffsetPx) + 5));
                        HOperatorSet.DispObj(ho_ContourYTick, hv_WindowHandle);
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
                            hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks,
                            out hv_TextHeightYTicks);
                        disp_message(hv_WindowHandle, hv_YTickValues.TupleSelect(hv_IndexTicks),
                            "window", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YPosition.TupleSelect(
                            hv_IndexTicks)), ((hv_LeftBorder - hv_TextWidthYTicks) - 2) + hv_YAxisOffsetPx,
                            hv_AxesColor, "false");
                    }
                }
            }
            //
            //Display funtion plot
            //
            if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
            {
                if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
                    new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
                {
                    hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())) / (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                        ));
                    //
                    //Iterate over all functions to be displayed
                    HTuple end_val482 = hv_Num - 1;
                    HTuple step_val482 = 1;
                    for (hv_I = 0; hv_I.Continue(end_val482, step_val482); hv_I = hv_I.TupleAdd(step_val482))
                    {
                        //Select y values for current function
                        hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(hv_I * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                            )), ((hv_I + 1) * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()))) - 1);
                        //Set color
                        if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
                        {
                            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                        }
                        else
                        {
                            HOperatorSet.SetColor(hv_WindowHandle, hv_Color.TupleSelect(hv_I % (new HTuple(hv_Color.TupleLength()
                                ))));
                        }
                        //
                        //Display in different styles
                        //
                        if ((int)((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(new HTuple(hv_Style.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            //Line
                            ho_Contour.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                            //Clip, if necessary
                            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder,
                                        hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                    ho_Contour.Dispose();
                                    ho_Contour = ExpTmpOutVar_0;
                                }
                            }
                            HOperatorSet.DispObj(ho_Contour, hv_WindowHandle);
                        }
                        else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
                        {
                            //Cross
                            ho_Cross.Dispose();
                            HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                6, 0.785398);
                            //Clip, if necessary
                            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder,
                                        hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                    ho_Cross.Dispose();
                                    ho_Cross = ExpTmpOutVar_0;
                                }
                            }
                            HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                        }
                        else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
                        {
                            //Filled
                            hv_Y1Selected = new HTuple();
                            hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_OriginY);
                            hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
                            hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_OriginY);
                            hv_X1Selected = new HTuple();
                            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                                );
                            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
                            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                                );
                            HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                            ho_Filled.Dispose();
                            HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height - hv_LowerBorder) - (hv_Y1Selected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                ((hv_X1Selected * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                            //Clip, if necessary
                            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder,
                                        hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                    ho_Filled.Dispose();
                                    ho_Filled = ExpTmpOutVar_0;
                                }
                            }
                            HOperatorSet.DispObj(ho_Filled, hv_WindowHandle);
                        }
                        else
                        {
                            throw new HalconException("Unsupported style: " + hv_Style);
                        }
                    }
                }
            }
            //
            //
            //Reset original display settings
            HOperatorSet.SetPart(hv_WindowHandle, hv_PartRow1, hv_PartColumn1, hv_PartRow2,
                hv_PartColumn2);
            //dev_set_window(...);
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
            HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
            HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
            ho_ContourXGrid.Dispose();
            ho_ContourYGrid.Dispose();
            ho_XArrow.Dispose();
            ho_YArrow.Dispose();
            ho_ContourXTick.Dispose();
            ho_ContourYTick.Dispose();
            ho_Contour.Dispose();
            ho_Cross.Dispose();
            ho_Filled.Dispose();

            return;
        }

    }
}